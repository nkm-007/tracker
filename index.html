<!DOCTYPE html>
<html>
<head>
    <title>AI Sports Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        /* --- MOBILE LAYOUT RESET --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; overflow: hidden; height: 100dvh; width: 100vw; }
        
        /* FULLSCREEN VIDEO CONTAINER */
        #container { position: relative; width: 100%; height: 100%; background: #000; }
        video { width: 100%; height: 100%; object-fit: cover; display: block; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* --- TOP BAR (Status & Settings) --- */
        #topBar {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 15px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex; justify-content: space-between; align-items: center;
            z-index: 10; color: white;
        }

        #status {
            font-size: 13px; font-weight: 500; color: #00ff88;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            display: flex; align-items: center; gap: 6px;
        }

        .settings-group { display: flex; gap: 10px; align-items: center; }

        #ipInput {
            background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 6px 10px; border-radius: 8px; width: 110px;
            font-size: 12px; text-align: center; outline: none; backdrop-filter: blur(4px);
        }
        #ipInput::placeholder { color: rgba(255,255,255,0.5); }

        /* --- BOTTOM CONTROLS --- */
        #controls {
            position: absolute; bottom: 0; left: 0; width: 100%;
            padding: 20px 20px 40px 20px; /* Extra padding for iPhone Home bar */
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: center;
            z-index: 10;
        }

        /* Target Selector (Left) */
        .mode-select {
            position: relative;
            background: rgba(255,255,255,0.1); border-radius: 20px;
            padding: 0 10px; backdrop-filter: blur(5px);
        }
        select {
            appearance: none; background: transparent; border: none;
            color: white; padding: 10px 5px; font-size: 13px; font-weight: bold;
            outline: none; text-align: center;
        }

        /* Shutter Button (Center) */
        #shutterBtn {
            width: 72px; height: 72px;
            border-radius: 50%;
            border: 4px solid white;
            background: transparent;
            position: relative;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex; align-items: center; justify-content: center;
        }
        
        #shutterBtn::after {
            content: ''; width: 56px; height: 56px;
            background: #ff4757; border-radius: 50%;
            transition: all 0.2s;
        }

        /* Recording State */
        #shutterBtn.recording { border-color: #ff4757; }
        #shutterBtn.recording::after {
            width: 30px; height: 30px; border-radius: 6px; /* Turns into a square stop button */
        }

        /* Utility Buttons (Right) */
        .utility-group { display: flex; flex-direction: column; gap: 15px; align-items: center; }

        .icon-btn {
            background: rgba(255,255,255,0.15); border: none;
            width: 40px; height: 40px; border-radius: 50%;
            color: white; font-size: 18px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); transition: background 0.2s;
        }
        .icon-btn:active { background: rgba(255,255,255,0.3); transform: scale(0.95); }

        /* Pulse Animation for Recording Text */
        @keyframes pulseDot { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .rec-dot { width: 8px; height: 8px; background: #ff4757; border-radius: 50%; display: none; margin-right: 5px; }
        .recording .rec-dot { display: inline-block; animation: pulseDot 1s infinite; }

    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <div id="topBar">
        <div id="status"><span class="rec-dot"></span> <span id="statusText">Loading AI...</span></div>
        <div class="settings-group">
            <input type="text" id="ip" placeholder="NodeIP" value="192.168.0.105">
        </div>
    </div>

    <div id="controls">
        <div class="mode-select">
            <select id="targetType">
                <option value="person">üßç Person</option>
                <option value="sports ball">‚öΩ Ball</option>
            </select>
        </div>

        <div id="shutterBtn" onclick="toggleTracking()"></div>

        <div class="utility-group">
            <button class="icon-btn" onclick="switchCamera()">üì∑</button>
            <button class="icon-btn" onclick="centerMotor()" style="color:#ffa502">üéØ</button>
        </div>
    </div>
</div>

<script>
    let video, canvas, ctx, model;
    let isTracking = false;
    let lastRequestTime = 0;
    
    // Recording Variables
    let mediaRecorder;
    let recordedChunks = [];
    let stream;
    let facingMode = 'environment'; // Default to Back Camera

    // 1. Initialize
    async function init() {
        video = document.getElementById('video');
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');

        // Setup Camera
        await startCamera();

        // Load AI
        document.getElementById('statusText').innerText = "Loading Model...";
        model = await cocoSsd.load();
        document.getElementById('statusText').innerText = "Ready to Record";
        
        // Start loop (it will idle until isTracking is true)
        trackLoop();
    }

    async function startCamera() {
        if (stream) stream.getTracks().forEach(t => t.stop());

        stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                facingMode: facingMode,
                width: { ideal: 1280 }, 
                height: { ideal: 720 } 
            },
            audio: false 
        });
        
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        };
    }

    function switchCamera() {
        facingMode = facingMode === 'user' ? 'environment' : 'user';
        startCamera();
    }

    // 2. Main Action: Toggle Recording + Tracking
    function toggleTracking() {
        const btn = document.getElementById('shutterBtn');
        const status = document.getElementById('status');
        const txt = document.getElementById('statusText');
        
        if (!isTracking) {
            // --- START ---
            isTracking = true;
            btn.classList.add('recording');
            status.classList.add('recording'); // Shows red dot
            txt.innerText = "REC 00:00";
            
            // Start Recording
            recordedChunks = [];
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            } catch (e) {
                mediaRecorder = new MediaRecorder(stream);
            }
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };
            
            mediaRecorder.onstop = saveAndShare;
            mediaRecorder.start();

        } else {
            // --- STOP ---
            isTracking = false;
            btn.classList.remove('recording');
            status.classList.remove('recording');
            txt.innerText = "Saving Video...";
            
            mediaRecorder.stop();
        }
    }

    // 3. Save & Share Logic
    async function saveAndShare() {
        const blob = new Blob(recordedChunks, { type: 'video/mp4' });
        const file = new File([blob], "tracking_clip.mp4", { type: 'video/mp4' });

        if (navigator.canShare && navigator.share) {
            try {
                await navigator.share({
                    files: [file],
                    title: 'Smart Tracker Clip',
                    text: 'Recorded via NodeMCU Tracker'
                });
                document.getElementById('statusText').innerText = "Ready";
            } catch (err) {
                document.getElementById('statusText').innerText = "Ready"; // User cancelled share
            }
        } else {
            // Fallback for Desktop
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "tracking_clip.mp4";
            a.click();
            document.getElementById('statusText').innerText = "Downloaded";
        }
    }

    // 4. AI Logic
    async function trackLoop() {
        requestAnimationFrame(trackLoop); // Keep loop running always for visuals
        
        if (!isTracking || !model) return; // Only process AI if tracking is ON

        const predictions = await model.detect(video);
        const targetType = document.getElementById('targetType').value;
        const target = predictions.find(p => p.class === targetType && p.score > 0.5);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (target) {
            // Draw Visuals
            ctx.strokeStyle = "#00ff88";
            ctx.lineWidth = 4;
            ctx.strokeRect(...target.bbox);

            // Motor Logic
            const x = target.bbox[0];
            const width = target.bbox[2];
            const centerX = x + (width / 2);
            const screenCenter = canvas.width / 2;
            const error = centerX - screenCenter;

            // Send command if outside deadzone
            if (Math.abs(error) > 50) {
                let steps = Math.floor(error / 10);
                if (facingMode === 'user') steps = -steps; // Mirror fix
                
                sendCommand(steps);
            }
        }
    }

    function sendCommand(steps) {
        const now = Date.now();
        // Limit to 10 commands/sec
        if (now - lastRequestTime > 100) {
            const ip = document.getElementById('ip').value;
            // Use no-cors to avoid errors, we just want to fire the request
            fetch(`http://${ip}/move?steps=${steps}`, { mode: 'no-cors' }).catch(e => {});
            lastRequestTime = now;
        }
    }

    function centerMotor() {
        const ip = document.getElementById('ip').value;
        fetch(`http://${ip}/stop`, { mode: 'no-cors' }).catch(e => {});
    }

    // Boot up
    init();
</script>
</body>
</html>
