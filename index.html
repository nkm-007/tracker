<!DOCTYPE html>
<html>
<head>
    <title>AI Sports Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        body { margin: 0; background: #000; font-family: sans-serif; overflow: hidden; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        video { width: 100%; height: 100%; object-fit: cover; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* UI Overlay */
        #ui {
            position: absolute; bottom: 20px; left: 0; width: 100%;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
            pointer-events: auto; z-index: 10;
        }
        
        .controls {
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 20px;
            backdrop-filter: blur(5px); display: flex; gap: 10px; align-items: center;
        }

        input { padding: 8px; border-radius: 5px; border: none; width: 120px; text-align: center; }
        
        button {
            padding: 10px 20px; border-radius: 25px; border: none;
            font-weight: bold; font-size: 14px; cursor: pointer;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }
        
        .btn-rec { background: #ff4757; color: white; display: flex; align-items: center; gap: 5px; }
        .btn-rec.recording { background: white; color: #ff4757; animation: pulse 1s infinite; }
        .btn-calib { background: #ffa502; color: white; }
        
        #status {
            color: #00ff88; font-size: 12px; background: rgba(0,0,0,0.7);
            padding: 5px 10px; border-radius: 10px;
        }

        /* Camera Switcher */
        #camSwitch {
            position: absolute; top: 20px; right: 20px;
            background: rgba(255,255,255,0.2); padding: 10px; border-radius: 50%;
            cursor: pointer; z-index: 20; color: white;
        }

        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
    
    <div id="camSwitch" onclick="switchCamera()">üì∑</div>

    <div id="ui">
        <div id="status">Loading AI Model...</div>
        
        <div class="controls">
            <input type="text" id="ip" placeholder="NodeMCU IP" value="192.168.0.105">
            <button class="btn-rec" id="recBtn" onclick="toggleRecording()">
                <span id="recIcon">‚óè</span> <span id="recText">REC & TRACK</span>
            </button>
            <button class="btn-calib" onclick="centerMotor()">üéØ Zero</button>
        </div>
        
        <div style="color:gray; font-size:10px; margin-top:5px;">
            Target: <select id="targetType" style="background:none; border:none; color:white;">
                <option value="person">Person (Testing)</option>
                <option value="sports ball">Football (Match)</option>
            </select>
        </div>
    </div>
</div>

<script>
    let video, canvas, ctx;
    let model;
    let isTracking = false;
    let lastRequest = 0;
    
    // Recording vars
    let mediaRecorder;
    let recordedChunks = [];
    let stream;
    let facingMode = 'environment'; // Start with Back Camera

    // 1. Initialize
    async function init() {
        video = document.getElementById('video');
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        
        // Load COCO-SSD (Better than Face API)
        model = await cocoSsd.load();
        document.getElementById('status').innerText = "AI Ready. Enter IP & Start.";
        
        startCamera();
    }

    async function startCamera() {
        if(stream) stream.getTracks().forEach(t => t.stop());
        
        stream = await navigator.mediaDevices.getUserMedia({
            video: { 
                facingMode: facingMode,
                width: { ideal: 1280 }, 
                height: { ideal: 720 } 
            },
            audio: false // Mute for performance, add true if you want sound
        });
        
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        };
    }

    function switchCamera() {
        facingMode = facingMode === 'user' ? 'environment' : 'user';
        startCamera();
    }

    // 2. Recording Logic (Saves to Drive via Share Sheet)
    function toggleRecording() {
        const btn = document.getElementById('recBtn');
        const txt = document.getElementById('recText');
        
        if (!isTracking) {
            // START
            isTracking = true;
            recordedChunks = [];
            
            // Create Recorder
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
            } catch (e) {
                mediaRecorder = new MediaRecorder(stream); // Fallback
            }

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = saveVideo;
            mediaRecorder.start();

            btn.classList.add('recording');
            txt.innerText = "STOP & SAVE";
            track(); // Start AI Loop

        } else {
            // STOP
            isTracking = false;
            mediaRecorder.stop();
            btn.classList.remove('recording');
            txt.innerText = "REC & TRACK";
            document.getElementById('status').innerText = "Processing Video...";
        }
    }

    async function saveVideo() {
        const blob = new Blob(recordedChunks, { type: 'video/mp4' });
        const file = new File([blob], "football_match.mp4", { type: 'video/mp4' });

        // Use Native Share API (Works on Android/iOS)
        if (navigator.canShare && navigator.share) {
            try {
                await navigator.share({
                    files: [file],
                    title: 'Football Match',
                    text: 'Recorded via AI Tracker'
                });
                document.getElementById('status').innerText = "Saved!";
            } catch (err) {
                // Fallback for desktop: Download directly
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "match_recording.mp4";
                a.click();
            }
        } else {
            // Fallback
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "match_recording.mp4";
            a.click();
        }
    }

    // 3. AI Tracking Loop
    async function track() {
        if (!isTracking) return;

        // Detect objects
        const predictions = await model.detect(video);
        const targetType = document.getElementById('targetType').value;
        
        // Filter for specific object (Person or Ball)
        const target = predictions.find(p => p.class === targetType && p.score > 0.5);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (target) {
            // Draw Box
            ctx.strokeStyle = "#00ff88";
            ctx.lineWidth = 4;
            ctx.strokeRect(...target.bbox);
            
            // Calculate Movement
            const x = target.bbox[0];
            const width = target.bbox[2];
            const centerX = x + (width / 2);
            
            // Screen Center
            const screenCenter = canvas.width / 2;
            
            // Error: How far is the object from the center?
            const error = centerX - screenCenter;

            // DEADZONE: If within 50px of center, don't move (stability)
            if (Math.abs(error) > 50) {
                
                // SPEED CALCULATION:
                // Far away (Error > 200) = Move Fast
                // Close (Error < 100) = Move Slow
                let motorSpeed = Math.floor(error / 10); 
                
                // INVERT Logic:
                // If using back camera, Left is Left.
                // If using front camera, Left is Right (Mirrored).
                if (facingMode === 'user') motorSpeed = -motorSpeed;

                // Send to NodeMCU
                sendToMotor(motorSpeed);
            }
        }

        requestAnimationFrame(track);
    }

    function sendToMotor(steps) {
        const now = Date.now();
        // Limit requests to 10 per second to prevent flooding WiFi
        if (now - lastRequest > 100) {
            const ip = document.getElementById('ip').value;
            // Send relative move command
            fetch(`http://${ip}/update?val=${steps}`).catch(e => console.log("Wifi Error"));
            lastRequest = now;
        }
    }

    function centerMotor() {
        const ip = document.getElementById('ip').value;
        fetch(`http://${ip}/reset`);
    }

    init();
</script>
</body>
</html>
