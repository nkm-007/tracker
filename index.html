<!DOCTYPE html>
<html>
<head>
    <title>AI Tracker Fixed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: #000; font-family: sans-serif; overflow: hidden; height: 100vh; }
        
        #container { position: relative; width: 100%; height: 100%; }
        video { width: 100%; height: 100%; object-fit: cover; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* HUD */
        #topBar {
            position: absolute; top: 0; width: 100%; padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            color: #00ff88; font-weight: bold; display: flex; justify-content: space-between; z-index: 10;
        }
        #controls {
            position: absolute; bottom: 0; width: 100%; padding: 30px 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex; justify-content: space-between; align-items: center; z-index: 10;
        }

        /* Inputs & Buttons */
        input { background: rgba(255,255,255,0.2); border: 1px solid #fff; padding: 8px; color: white; width: 120px; text-align: center; border-radius: 8px; }
        
        #shutterBtn {
            width: 70px; height: 70px; border-radius: 50%; border: 4px solid white;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        #innerBtn { width: 55px; height: 55px; background: #ff4757; border-radius: 50%; transition: 0.2s; }
        
        .recording #innerBtn { width: 30px; height: 30px; border-radius: 5px; }
        .icon-btn { font-size: 24px; background: none; border: none; cursor: pointer; }
    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>

    <div id="topBar">
        <div id="status">Loading AI...</div>
        <input type="text" id="ip" placeholder="Type IP Here" value="192.168.">
    </div>

    <div id="controls">
        <button class="icon-btn" onclick="centerMotor()">ðŸŽ¯</button>
        <div id="shutterBtn" onclick="toggleRec()"><div id="innerBtn"></div></div>
        <button class="icon-btn" onclick="switchCam()">ðŸ“·</button>
    </div>
</div>

<script>
    let video, canvas, ctx, model;
    let isTracking = false;
    let lastTime = 0;
    
    // Recording
    let mediaRecorder, chunks = [];
    let stream, facing = 'environment';

    async function init() {
        video = document.getElementById('video');
        canvas = document.getElementById('canvas');
        ctx = canvas.getContext('2d');
        
        await startCam();
        
        model = await cocoSsd.load();
        document.getElementById('status').innerText = "AI Ready - Enter IP";
        
        loop();
    }

    async function startCam() {
        if(stream) stream.getTracks().forEach(t=>t.stop());
        stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: facing, width: { ideal: 1280 }, height: { ideal: 720 } },
            audio: false
        });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }
    }

    function switchCam() {
        facing = facing==='user'?'environment':'user';
        startCam();
    }

    function toggleRec() {
        const btn = document.getElementById('shutterBtn');
        if(!isTracking) {
            isTracking = true;
            btn.classList.add('recording');
            document.getElementById('status').innerText = "TRACKING & RECORDING";
            chunks = [];
            
            try { mediaRecorder = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=vp9'}); }
            catch(e) { mediaRecorder = new MediaRecorder(stream); }
            
            mediaRecorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
            mediaRecorder.onstop = saveVideo;
            mediaRecorder.start();
        } else {
            isTracking = false;
            btn.classList.remove('recording');
            document.getElementById('status').innerText = "Saving...";
            mediaRecorder.stop();
        }
    }

    async function saveVideo() {
        const blob = new Blob(chunks, {type: 'video/mp4'});
        const file = new File([blob], "tracking.mp4", {type:'video/mp4'});
        if(navigator.canShare && navigator.share) {
            try { await navigator.share({files:[file], title:'Video'}); } catch(e){}
        } else {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "video.mp4";
            a.click();
        }
        document.getElementById('status').innerText = "Ready";
    }

    async function loop() {
        requestAnimationFrame(loop);
        if(!isTracking || !model) return;

        const preds = await model.detect(video);
        const person = preds.find(p => p.class === 'person' && p.score > 0.5);

        ctx.clearRect(0,0,canvas.width,canvas.height);

        if(person) {
            ctx.strokeStyle = "#00ff88"; ctx.lineWidth = 4;
            ctx.strokeRect(...person.bbox);

            const x = person.bbox[0];
            const w = person.bbox[2];
            const center = x + w/2;
            const screenCenter = canvas.width/2;
            const error = center - screenCenter;

            // DEADZONE: Must move more than 60px to trigger motor
            if(Math.abs(error) > 60) {
                // Determine steps based on distance
                let steps = Math.floor(error / 8); 
                
                // --- DIRECTION FIX ---
                // If it was moving opposite, we multiply by -1.
                // CURRENT SETTING: Inverted
                steps = steps * -1; 
                
                // Send command
                send(steps);
            }
        }
    }

    function send(steps) {
        const now = Date.now();
        // Throttle: Only send every 150ms to prevent Timeouts
        if(now - lastTime > 150) {
            const ip = document.getElementById('ip').value;
            // Use 'no-cors' mode (fire and forget)
            fetch(`http://${ip}/move?steps=${steps}`, {mode: 'no-cors'}).catch(e=>{
                // If this fails, IP is wrong or NodeMCU is busy
                console.log("Connect Error"); 
            });
            lastTime = now;
        }
    }

    function centerMotor() {
        const ip = document.getElementById('ip').value;
        fetch(`http://${ip}/stop`, {mode: 'no-cors'});
    }

    init();
</script>
</body>
</html>
